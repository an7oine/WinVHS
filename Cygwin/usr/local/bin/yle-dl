#!/usr/bin/env python2
# -*- coding: utf-8 -*-

"""
yle-dl - rtmpdump frontend for Yle Areena, Elävä Arkisto and YleX Areena

Copyright (C) 2010-2014 Antti Ajanki <antti.ajanki@iki.fi>

This script extracts RTMP stream information from Yle Areena
(http://areena.yle.fi), YleX Areena (http://ylex.yle.fi/ylex-areena),
Elävä Arkisto (http://yle.fi/elavaarkisto/index.html) web pages and
calls rtmpdump with correct parameters.
"""

import sys
import urllib
import urllib2
import re
import subprocess
import os
import os.path
import platform
import signal
import urlparse
import htmlentitydefs
import json
import string
import xml.dom.minidom
import time
import codecs
import base64
import ctypes
import ctypes.util
from operator import itemgetter
from Crypto.Cipher import AES

version = '2.3.1'

AREENA_NG_SWF = 'http://areena.yle.fi/static/player/1.2.8/flowplayer/flowplayer.commercial-3.2.7-encrypted.swf'
AREENA_NG_HTTP_HEADERS = {'User-Agent': 'yle-dl/' + version.split(' ')[0]}

ARKISTO_SWF = 'http://yle.fi/elavaarkisto/flowplayer/flowplayer.commercial-3.2.7.swf?0.7134730119723827'
RTMPDUMP_OPTIONS_ARKISTO = ['-s', ARKISTO_SWF, '-m', '60']

RTMPDUMP_OPTIONS_YLEX = ['-m', '60']

RTMP_SCHEMES = ['rtmp', 'rtmpe', 'rtmps', 'rtmpt', 'rtmpte', 'rtmpts']

# list of all options that require an argument
ARGOPTS = ('--rtmp', '-r', '--host', '-n', '--port', '-c', '--socks',
           '-S', '--swfUrl', '-s', '--tcUrl', '-t', '--pageUrl', '-p',
           '--app', '-a', '--swfhash', '-w', '--swfsize', '-x', '--swfVfy',
           '-W', '--swfAge', '-X', '--auth', '-u', '--conn', '-C',
           '--flashVer', '-f', '--subscribe', '-d', '--flv', '-o',
           '--timeout', '-m', '--start', '-A', '--stop', '-B', '--token',
           '-T', '--skip', '-k', '--buffer', '-b')

# rtmpdump exit codes
RD_SUCCESS = 0
RD_FAILED = 1
RD_INCOMPLETE = 2

debug = False
excludechars_linux = '*/|'
excludechars_windows = '\"*/:<>?|'
excludechars = excludechars_linux
rtmpdump_binary = None
hds_binary = ['php', '/usr/local/bin/AdobeHDS.php']

libcname = ctypes.util.find_library('c')
libc = libcname and ctypes.CDLL(libcname)

def log(msg):
    enc = sys.stderr.encoding or 'UTF-8'
    sys.stderr.write(msg.encode(enc, 'backslashreplace'))
    sys.stderr.write('\n')
    sys.stderr.flush()

def splashscreen():
    log(u'yle-dl %s: Download media files from Yle Areena and Elävä Arkisto' % version)
    log(u'Copyright (C) 2009-2014 Antti Ajanki <antti.ajanki@iki.fi>, license: GPLv2')

def usage():
    """Print the usage message to stderr"""
    splashscreen()
    log(u'')
    log(u'%s [yle-dl or rtmpdump options] URL' % sys.argv[0])
    log(u'')
    log(u'yle-dl options:')
    log(u'')
    log(u'--latestepisode         Download the latest episode')
    log(u"--showurl               Print URL, don't download")
    log(u"--showtitle             Print stream title, don't download")
    log(u"--showepisodepage       Print web page for each episode")
    log(u'--vfat                  Create Windows-compatible filenames')
    log(u'--sublang lang          Download subtitles, lang = fin, swe, smi, none or all')
    log(u'--hardsubs              Download stream with hard subs if available')
    log(u'--maxbitrate br         Maximum bitrate stream to download, integer in kB/s')
    log(u'                        or "best" or "worst". Not exact on HDS streams.')
    log(u'--rtmpdump path         Set path to rtmpdump binary')
    log(u'--adobehds cmd          Set command for executing AdobeHDS.php script')
    log(u'                        Default: "php /usr/local/bin/AdobeHDS.php"')
    log(u'--destdir dir           Save files to dir')
    log(u'--protocol protos       Preferred streaming protocols (comma-separated)')
    log(u'                        Supported values: rtmp and hds')
    log(u'--pipe                  Dump stream to stdout for piping to media player')
    log(u'                        E.g. "yle-dl --pipe URL | vlc -"')
    log(u'')
    log(u'rtmpdump options:')
    log(u'')
    subprocess.call([rtmpdump_binary, '--help'])

def download_page(url):
    """Returns contents of a HTML page at url."""
    if url.find('://') == -1:
        url = 'http://' + url
    if '#' in url:
        url = url[:url.find('#')]

    request = urllib2.Request(url, headers=AREENA_NG_HTTP_HEADERS)
    try:
        urlreader = urllib2.urlopen(request)
        content = urlreader.read()

        charset = urlreader.info().getparam('charset')
        if not charset:
            metacharset = re.search(r'<meta [^>]*?charset="(.*?)"', content)
            if metacharset:
                charset = metacharset.group(1)
        if not charset:
            charset = 'iso-8859-1'

        return unicode(content, charset, 'replace')
    except urllib2.URLError, exc:
        log(u"Can't read %s: %s" % (url, exc))
        return None
    except ValueError:
        log(u'Invalid URL: ' + url)
        return None

def encode_url_utf8(url):
    """Encode the path component of url to percent-encoded UTF8."""
    (scheme, netloc, path, params, query, fragment) = urlparse.urlparse(url)

    path = path.encode('UTF8')

    # Assume that the path is already encoded if there seems to be
    # percent encoded entities.
    if re.search(r'%[0-9A-Fa-f]{2}', path) is None:
        path = urllib.quote(path, '/+')

    return urlparse.urlunparse((scheme, netloc, path, params, query, fragment))

def decode_html_entity(entity):
    if not entity:
        return u''

    try:
        x = htmlentitydefs.entitydefs[entity]
    except KeyError:
        x = entity

    if x.startswith('&#') and x[-1] == ';':
        x = x[1:-1]

    if x[0] == '#':
        try:
            return unichr(int(x[1:]))
        except (ValueError, OverflowError):
            return u'?'
    else:
        return unicode(x, 'iso-8859-1', 'ignore')

def replace_entitydefs(content):
    return re.sub(r'&(.*?);', lambda m: decode_html_entity(m.group(1)), content)

def int_or_else(x, default):
    try:
        return int(x)
    except ValueError:
        return default

def downloader_factory(url, protocols):
    if url.startswith('http://www.yle.fi/elavaarkisto/') or \
            url.startswith('http://yle.fi/elavaarkisto/') or \
            url.startswith('http://yle.fi/arkivet/') or \
            url.startswith('http://svenska.yle.fi/arkivet/'):
        return RetryingDownloader(ElavaArkistoDownloader, protocols)
    elif url.startswith('http://ylex.yle.fi/'):
        return RetryingDownloader(YleXDownloader, protocols)
    elif url.startswith('http://areena.yle.fi/tv/suora/') or \
            url.startswith('http://arenan.yle.fi/tv/direkt/'):
        return RetryingDownloader(AreenaLiveDownloader, protocols)
    elif re.match(r'^http://(www\.)?yle\.fi/radio/[a-zA-Z0-9]+/suora/?$', url) or \
            url == 'http://ylex.yle.fi/radio-popup':
        return RetryingDownloader(AreenaLiveRadioDownloader, protocols)
    elif url.startswith('http://areena.yle.fi/') or \
            url.startswith('http://arenan.yle.fi/') or \
            url.startswith('http://yle.fi/'):
        return RetryingDownloader(AreenaNGDownloader, protocols)
    elif url.startswith('http://areena.kokeile.yle.fi/'):
        return RetryingDownloader(Areena2014Downloader, protocols)
    else:
        return None

def bitrate_from_arg(arg):
    if arg == 'best':
        return sys.maxint
    elif arg == 'worst':
        return 0
    else:
        try:
            return int(arg)
        except ValueError:
            log(u'Invalid bitrate %s, defaulting to best' % arg)
            arg = sys.maxint

def which(program):
    """Search for program on $PATH and return the full path if found."""
    # Adapted from
    # http://stackoverflow.com/questions/377017/test-if-executable-exists-in-python

    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None

def parse_rtmp_single_component_app(rtmpurl):
    """Extract single path-component app and playpath from rtmpurl."""
    # YLE server requires that app is the first path component
    # only. By default librtmp would take the first two
    # components (app/appInstance).
    #
    # This also means that we can't rely on librtmp's playpath
    # parser and have to duplicate the logic here.
    k = 0
    if rtmpurl.find('://') != -1:
        i = -1
        for i, x in enumerate(rtmpurl):
            if x == '/':
                k += 1
                if k == 4:
                    break

        playpath = rtmpurl[(i+1):]
        app_only_rtmpurl = rtmpurl[:i]
    else:
        playpath = rtmpurl
        app_only_rtmpurl = ''

    ext = os.path.splitext(playpath)[1]
    if ext == '.mp4':
        playpath = 'mp4:' + playpath
        ext = '.flv'
    elif ext == '.mp3':
        playpath = 'mp3:' + playpath[:-4]

    return (app_only_rtmpurl, playpath, ext)


class StreamFilters:
    """Parameters for deciding which of potentially multiple available stream
    versions to download.
    """
    def __init__(self, latest_only, sublang, hardsubs, maxbitrate):
        self.latest_only = latest_only
        self.sublang = sublang
        self.hardsubs = hardsubs
        self.maxbitrate = maxbitrate

    def keep_lowest_bitrate(self):
        return self.maxbitrate <= 0


# Areena

class AreenaUtils:
    def areena_decrypt(self, data, aes_key):
        try:
            bytestring = base64.b64decode(str(data))
        except (UnicodeEncodeError, TypeError):
            return None

        iv = bytestring[:16]
        ciphertext = bytestring[16:]
        padlen = 16 - (len(ciphertext) % 16)
        ciphertext = ciphertext + '\0'*padlen

        decrypter = AES.new(aes_key, AES.MODE_CFB, iv, segment_size=16*8)
        return decrypter.decrypt(ciphertext)[:-padlen]


    def download_subtitles(self, subtitles, filters, videofilename):
        if not filters.hardsubs:
            preferred_lang = filters.sublang
            basename = os.path.splitext(videofilename)[0]
            for sub in subtitles:
                lang = sub.language
                if lang == preferred_lang or preferred_lang == 'all':
                    if sub.url:
                        try:
                            enc = sys.getfilesystemencoding()
                            filename = basename + '.' + lang + '.srt'
                            subtitlefile = filename.encode(enc, 'replace')
                            urllib.urlretrieve(sub.url, subtitlefile)
                            self.add_BOM(subtitlefile)
                            log(u'Subtitles saved to ' + filename)
                            if preferred_lang != 'all':
                                return
                        except IOError, exc:
                            log(u'Failed to download subtitles at %s: %s' % (sub.url, exc))

    def add_BOM(self, filename):
        """Add byte-order mark into a file.

        Assumes (but does not check!) that the file is UTF-8 encoded.
        """
        content = open(filename, 'r').read()
        if content.startswith(codecs.BOM_UTF8):
            return

        f = open(filename, 'w')
        f.write(codecs.BOM_UTF8)
        f.write(content)
        f.close()

    def parse_yle_date(self, yledate):
        """Convert strings like 2012-06-16T18:45:00 into a struct_time.

        Returns None if parsing fails.
        """
        try:
            return time.strptime(yledate, '%Y-%m-%dT%H:%M:%S')
        except (ValueError, TypeError):
            return None


class AreenaNGDownloader(AreenaUtils):
    OP_DOWNLOAD = 1
    OP_PRINT_DOWNLOAD_URL = 2
    OP_PRINT_EPISODE_PAGE_URL = 3
    OP_PIPE = 4

    @staticmethod
    def supported_protocols():
        return ['hds', 'rtmp']
    
    def __init__(self, streaming_protocol):
        if streaming_protocol == 'hds':
            self.stream_class = AreenaHDSStreamUrl
        else:
            self.stream_class = AreenaStreamUrl

    def download_episodes(self, url, filters, rtmpdumpargs, destdir):
        """Extract all episodes (or just the latest episode if
        latest_only is True) from url."""
        return self.process_episodes(url, filters, rtmpdumpargs, destdir,
                                     self.OP_DOWNLOAD)

    def print_urls(self, url, print_episode_url, filters):
        """Extract episodes from url and print their
        librtmp-compatible URLs on stdout."""
        optype = (self.OP_PRINT_EPISODE_PAGE_URL if (print_episode_url)
            else self.OP_PRINT_DOWNLOAD_URL)
        return self.process_episodes(url, filters, [], None, optype)

    def pipe(self, url, filters):
        return self.process_episodes(url, filters, [], None, self.OP_PIPE)

    def print_titles(self, url, filters):
        playlist = self.get_playlist(url, filters.latest_only)
        if not playlist:
            return RD_FAILED

        enc = sys.getfilesystemencoding()
        for clip in playlist:
            print self.get_clip_title(clip).encode(enc, 'replace')

        return RD_SUCCESS

    def process_episodes(self, url, filters, rtmpdumpargs, destdir, optype):
        playlist = self.get_playlist(url, filters.latest_only)
        if not playlist:
            return RD_FAILED

        overall_status = RD_SUCCESS
        for clip in playlist:

            # Areena's "all episodes" page does not include subtitle information, only 
            # the single episode pages do. So read the episode numbers from the "all 
            # episodes" page and then download the episodes individually.
            if (clip.has_key('id') and not clip['id'] in url and
                not clip.has_key('subtitles') and optype == self.OP_DOWNLOAD):
                url = "http://areena.yle.fi/tv/" + clip['id']
                print url
                
                res = self.download_episodes(url, filters, rtmpdumpargs, destdir)
            else:
                res = self.process_single_episode(clip, url, filters,
                                                  rtmpdumpargs, destdir, optype)
            if res != RD_SUCCESS:
                overall_status = res

        return overall_status

    def process_single_episode(self, clip, pageurl, filters, rtmpdumpargs,
                               destdir, optype):
        """Construct clip parameters and starts a rtmpdump process."""
        streamurl = self.stream_class(clip, pageurl, filters)
        if not streamurl.is_valid():
            log(u'Unsupported stream at %s: %s' %
                (pageurl, streamurl.get_error_message()))
            return RD_FAILED

        enc = sys.getfilesystemencoding()
        if optype == self.OP_PRINT_DOWNLOAD_URL:
            print streamurl.to_url().encode(enc, 'replace')
            return RD_SUCCESS
        elif optype == self.OP_PRINT_EPISODE_PAGE_URL:
            print streamurl.to_episode_url().encode(enc, 'replace')
            return RD_SUCCESS
        elif optype == self.OP_PIPE:
            return streamurl.create_pipe(filters.maxbitrate)

        downloader = streamurl.create_downloader(self.get_clip_title(clip),
                                                 destdir, rtmpdumpargs)
        if not downloader:
            log(u'Downloading the stream at %s is not yet supported.' % pageurl)
            log(u'Try --showurl')
            return RD_FAILED

        outputfile = downloader.output_filename()
        self.download_subtitles(self.clip_subtitles(clip), filters, outputfile)
        return downloader.save_stream()

    def get_clip_title(self, clip):
        if 'channel' in clip:
            # Live radio broadcast
            curtime = time.strftime('-%Y-%m-%d-%H:%M:%S')
            title = clip['channel'].get('name', 'yle-radio') + curtime

        elif 'title' in clip:
            # Video or radio stream
            title = clip['title']
            date = None
            broadcasted = clip.get('broadcasted', None)
            if broadcasted:
                date = broadcasted.get('date', None)
            if not date:
                date = clip.get('published', None)
            if date:
                title += '-' + date.replace('/', '-').replace(' ', '-')

        else:
            title = time.strftime('areena-%Y-%m-%d-%H:%M:%S')

        return title

    def get_playlist(self, url, latest_episode):
        (scheme, netloc, path, params, query, fragment) = urlparse.urlparse(url)
        episodeurl = urlparse.urlunparse((scheme, netloc, path + '.json', params, query, ''))
        fulldata = self.load_metadata(episodeurl)
        if fulldata is None:
            return None

        playlist = []
        if 'contentType' in fulldata or 'channel' in fulldata:
            playlist = [fulldata]
        elif 'search' in fulldata:
            playlist = fulldata['search'].get('results', [])
        elif 'availableEpisodes' in fulldata or \
                'availableClips' in fulldata:
            playlist = self.get_full_series_playlist(url)

        if latest_episode:
            playlist = sorted(playlist, key=self.get_media_time)[-1:]

        return playlist

    def get_full_series_playlist(self, url):
        playlist = []
        (scheme, netloc, path, params, query, fragment) = urlparse.urlparse(url)
        program_types = ['ohjelmat', 'muut']
        for ptype in program_types:
            size_query = 'from=0&to=1000&sisalto=%s' % ptype
            searchurl = urlparse.urlunparse((scheme, netloc, path + '.json',
                                             params, query + size_query, ''))
            fulldata = self.load_metadata(searchurl)
            if fulldata is not None:
                playlist.extend(fulldata.get('search', {}).get('results', []))
        return playlist

    def load_metadata(self, url):
        jsonstr = download_page(url)
        if not jsonstr:
            return None
        
        if debug:
            log(url)
            log(jsonstr)
        
        try:
            metadata = json.loads(jsonstr)
        except ValueError:
            log(u'Invalid JSON file at ' +  url)
            return None

        return metadata

    def clip_subtitles(self, clip):
        subdata = clip.get('media', {}).get('subtitles', [])
        return [Subtitle(s.get('url'), s.get('lang', '')) for s in subdata
                if s.get('url')]

    def get_media_time(self, media):
        """Extract date (as struct_time) from media metadata."""
        broadcasted = media.get('broadcasted', {}) or {}
        return self.parse_yle_date(broadcasted.get('date', None)) or \
            self.parse_yle_date(media.get('published', None)) or \
            time.gmtime(0)


### Areena stream URL ###


class AreenaStreamBase(AreenaUtils):
    def __init__(self, clip, pageurl):
        self.error = None
        self.episodeurl = self.create_pageurl(clip) or pageurl

    def is_valid(self):
        return not self.error
    
    def get_error_message(self):
        if self.is_valid():
            return None
        else:
            return self.error or 'Stream not valid'
    
    def to_url(self):
        return ''

    def to_episode_url(self):
        return self.episodeurl

    def to_rtmpdump_args(self):
        return None

    def create_pageurl(self, media):
        if not media or 'type' not in media or 'id' not in media:
            return ''

        if media['type'] == 'audio':
            urltype = 'radio'
        else:
            urltype = 'tv'

        return 'http://areena.yle.fi/%s/%s' % (urltype, media['id'])

    def get_metadata(self, clip):
        metadata_page = self.create_pageurl(clip)
        if not metadata_page:
            return None

        jsonurl = metadata_page + '.json'
        jsonstr = download_page(jsonurl)
        if not jsonstr:
            return None

        try:
            clipjson = json.loads(jsonstr)
        except ValueError:
            log(u'Invalid JSON file at ' +  jsonurl)
            return None

        return clipjson

    def full_metadata_if_search_result(self, clip):
        # Search results don't have the media item so we have to
        # download clip metadata from the source.
        if not clip:
            return {}
        elif not clip.has_key('media'):
            clip = self.get_metadata(clip)
        return clip

    def stream_from_papi(self, papiurl, aes_key, filters):
        papi = download_page(papiurl)
        if not papi:
            log('Failed to download papi')
            return None

        if papi.startswith('<media>'):
            papi_decoded = papi
        else:
            papi_decoded = self.areena_decrypt(papi, aes_key)

        if debug:
            log(papi_decoded)

        try:
            papi_xml = xml.dom.minidom.parseString(papi_decoded)
        except Exception as exc:
            log(unicode(exc.message, 'utf-8', 'ignore'))
            return None

        streams = self.all_streams_from_papi(papi_xml)
        if not streams:
            log('No streams found in papi')
            return None

        withsubs = self.filter_by_hard_subtitles(streams, filters)
        best = self.select_quality(withsubs, filters)
        if not best:
            log('No streams matching the bitrate limit')
            return None

        if debug:
            log('Selected stream')
            log(str(best))

        return best

    def all_streams_from_papi(self, papi):
        streams = []
        assets = papi.getElementsByTagName('onlineAsset')
        for asset in assets:
            urls = asset.getElementsByTagName('url')
            if urls and len(urls) >= 1:
                connect = self.extract_child_content(urls[0], 'connect')
                stream = self.extract_child_content(urls[0], 'stream')
                if connect:
                    videoBR = self.extract_child_content(asset, 'videoBitrate') or ''
                    audioBR = self.extract_child_content(asset, 'audioBitrate') or ''
                    subtitles = self.extract_child_content(asset, 'hardSubtitles') or ''
                    streams.append(PAPIStream(connect, stream, videoBR,
                                              audioBR, subtitles))
        return streams

    def extract_child_content(self, node, childName):
        child = node.getElementsByTagName(childName)
        if child.length > 0 and child[0].firstChild:
            return child[0].firstChild.nodeValue
        else:
            return None

    def filter_by_hard_subtitles(self, streams, filters):
        if filters.hardsubs and filters.sublang == 'all':
            filtered = streams
        elif filters.hardsubs and filters.sublang != 'none':
            filtered = [s for s in streams if s.hardSubtitles == filters.sublang]
        else:
            filtered = [s for s in streams if not s.hardSubtitles]
        return filtered or streams

    def select_quality(self, streams, filters):
        if filters.keep_lowest_bitrate():
            # lowest quality stream
            return sorted(streams, key=lambda x: x.bitrate())[0]
        else:
            # highest quality stream below maxbitrate
            below_limit = [x for x in streams if x.bitrate() < filters.maxbitrate]
            if below_limit:
                return sorted(below_limit, key=lambda x: x.bitrate())[-1]
            else:
                return None


class AreenaRTMPStreamUrl(AreenaStreamBase):
    # Extracted from
    # http://areena.yle.fi/static/player/1.2.8/flowplayer/flowplayer.commercial-3.2.7-encrypted.swf
    AES_KEY = 'hjsadf89hk123ghk'

    def __init__(self, clip, pageurl):
        AreenaStreamBase.__init__(self, clip, pageurl)
        self.rtmp_params = None

    def is_valid(self):
        return bool(self.rtmp_params)

    def to_url(self):
        return self.rtmp_parameters_to_url(self.rtmp_params)

    def to_rtmpdump_args(self):
        if self.rtmp_params:
            return self.rtmp_parameters_to_rtmpdump_args(self.rtmp_params)
        else:
            return []

    def create_downloader(self, clip_title, destdir, extra_argv):
        if not self.to_rtmpdump_args():
            return None
        else:
            return RTMPDump(self, clip_title, destdir, extra_argv)

    def create_pipe(self, dummy):
        args = [rtmpdump_binary]
        args += self.rtmp_parameters_to_rtmpdump_args(self.rtmp_params)
        args += ['-o', '-']
        enc = sys.getfilesystemencoding()
        encoded_args = [x.encode(enc, 'replace') for x in args]
        return subprocess.Popen(encoded_args).wait()

    def rtmp_parameters_from_papi(self, papiurl, pageurl, islive, filters):
        stream = self.stream_from_papi(papiurl, self.AES_KEY, filters)
        return self.stream_to_rtmp_parameters(stream, pageurl, islive)

    def stream_to_rtmp_parameters(self, stream, pageurl, islive):
        if not stream:
            return None
        
        rtmp_connect = stream.connect
        rtmp_stream = stream.stream
        if not rtmp_stream:
            log('No rtmp stream')
            return None

        try:
            scheme, edgefcs, rtmppath = self.rtmpurlparse(rtmp_connect)
        except ValueError as exc:
            log(unicode(exc.message, 'utf-8', 'ignore'))
            return None

        ident = download_page('http://%s/fcs/ident' % edgefcs)
        if ident is None:
            log('Failed to read ident')
            return None

        if debug:
            log(ident)

        try:
            identxml = xml.dom.minidom.parseString(ident)
        except Exception as exc:
            log(unicode(exc.message, 'utf-8', 'ignore'))
            return None

        nodelist = identxml.getElementsByTagName('ip')
        if len(nodelist) < 1 or len(nodelist[0].childNodes) < 1:
            log('No <ip> node!')
            return None
        rtmp_ip = nodelist[0].firstChild.nodeValue

        app_without_fcsvhost = rtmppath.lstrip('/')
        app_fields = app_without_fcsvhost.split('?', 1)
        baseapp = app_fields[0]
        if len(app_fields) > 1:
            auth = app_fields[1]
        else:
            auth = ''
        app = '%s?_fcs_vhost=%s&%s' % (baseapp, edgefcs, auth)
        rtmpbase = '%s://%s/%s' % (scheme, edgefcs, baseapp)
        tcurl = '%s://%s/%s' % (scheme, rtmp_ip, app)

        rtmpparams = {'rtmp': rtmpbase,
                      'app': app,
                      'playpath': rtmp_stream,
                      'tcUrl': tcurl,
                      'pageUrl': pageurl,
                      'swfUrl': AREENA_NG_SWF}
        if islive:
            rtmpparams['live'] = '1'

        return rtmpparams
    
    def rtmpurlparse(self, url):
        if '://' not in url:
            raise ValueError("Invalid RTMP URL")

        scheme, rest = url.split('://', 1)
        if scheme not in RTMP_SCHEMES:
            raise ValueError("Invalid RTMP URL")

        if '/' not in rest:
            raise ValueError("Invalid RTMP URL")

        server, app_and_playpath = rest.split('/', 1)
        return (scheme, server, app_and_playpath)

    def rtmp_parameters_to_url(self, params):
        components = [params['rtmp']]
        for key, value in params.iteritems():
            if key != 'rtmp':
                components.append('%s=%s' % (key, value))
        return ' '.join(components)

    def rtmp_parameters_to_rtmpdump_args(self, params):
        args = []
        for key, value in params.iteritems():
            if key == 'live':
                args.append('--live')
            else:
                args.append('--%s=%s' % (key, value))
        return args


class AreenaStreamUrl(AreenaRTMPStreamUrl):
    def __init__(self, clip, pageurl, filters):
        AreenaRTMPStreamUrl.__init__(self, clip, pageurl)
        self.direct_url = None
        if clip:
            if 'channel' in clip:
                self._initialize_liveradio_parameters(clip, pageurl, filters)
            else:
                self._initialize_tv_stream(clip, pageurl, filters)

    def is_valid(self):
        return bool(self.rtmp_params) or bool(self.direct_url)

    def to_url(self):
        if self.rtmp_params:
            return self.rtmp_parameters_to_url(self.rtmp_params)
        elif self.direct_url:
            return self.direct_url
        else:
            return ''

    def _initialize_liveradio_parameters(self, clip, pageurl, filters):
        channel = clip.get('channel', {})
        lang = channel.get('lang', 'fi')
        radioid = channel.get('id', None)
        if not radioid:
            self.error = 'id missing'
            return

        papiurl = 'http://papi.yle.fi/ng/radio/rtmp/%s/%s' % (radioid, lang)
        self.rtmp_params = self.rtmp_parameters_from_papi(papiurl, pageurl, True, filters)

    def _initialize_tv_stream(self, clip, pageurl, filters):
        clip = self.full_metadata_if_search_result(clip) or {}
        media = clip.get('media', {})
        if media.get('id'):
            self._parse_rtmp_url(media, pageurl, filters)
        elif media.get('mediaUrl'):
            self._parse_direct_media_url(media)
        elif media.get('downloadUrl'):
            self._parse_direct_download_url(media)
        else:
            self.error = 'No id, mediaUrl or downloadUrl'

    def _parse_rtmp_url(self, media, pageurl, filters):
        if media.get('live', False):
            islive = True
            papiurl = 'http://papi.yle.fi/ng/live/rtmp/' + media['id'] + '/fin'
        else:
            islive = False
            papiurl = 'http://papi.yle.fi/ng/mod/rtmp/' + media['id']

        self.rtmp_params = \
          self.rtmp_parameters_from_papi(papiurl, pageurl, islive, filters)

    def _parse_direct_media_url(self, media):
        self.direct_url = media.get('mediaUrl')

    def _parse_direct_download_url(self, media):
        self.direct_url = media.get('downloadUrl')


class AreenaHDSStreamUrl(AreenaStreamBase):
    # Extracted from
    # http://areena.yle.fi/static/player/1.3.12/flowplayer/flowplayer.commercial-3.2.16-encrypted.swf
    HDS_AES_KEY = 'C6F258503B21E30A'
    
    def __init__(self, clip, pageurl, filters):
        AreenaStreamBase.__init__(self, clip, pageurl)
        self.hds_url = self._initialize_hds_stream(clip, pageurl, filters)
        self.maxbitrate = filters.maxbitrate

    def to_url(self):
        return self.hds_url or ''

    def create_downloader(self, clip_title, destdir, extra_argv):
        return HDSDump(self, clip_title, destdir, extra_argv, self.maxbitrate)

    def create_pipe(self, maxbitrate):
        args = list(hds_binary)
        if maxbitrate < 1000:
            args.append('--quality low')
        elif maxbitrate < 2000:
            args.append('--quality medium')
        args.append('--manifest')
        args.append(self.to_url())
        args.append('--play')
        enc = sys.getfilesystemencoding()
        encoded_args = [x.encode(enc, 'replace') for x in args]
        return subprocess.Popen(encoded_args).wait()

    def _initialize_hds_stream(self, clip, pageurl, filters):
        clip = self.full_metadata_if_search_result(clip) or {}
        media = clip.get('media', {})
        if media.get('id'):
            return self._parse_hds_url(media, pageurl, filters)
        else:
            self.error = 'Media ID missing'
            return None

    def _parse_hds_url(self, media, pageurl, filters):
        if media.get('live', False):
            islive = True
            papiurl = 'http://papi.yle.fi/ng/live/hds/' + media['id'] + '/fin'
        else:
            islive = False
            papiurl = 'http://papi.yle.fi/ng/mod/hds/' + media['id']

        stream = self.stream_from_papi(papiurl, self.HDS_AES_KEY, filters)
        if not stream or not stream.connect:
            self.error = 'HDS stream not found'
            return None
        else:
            return stream.connect + '&g=ABCDEFGHIJKL&hdcore=3.3.0&plugin=flowplayer-3.3.0.0'


class Areena2014HDSStreamUrl(AreenaHDSStreamUrl):
    def __init__(self, pageurl, hdsurl, filters):
        AreenaHDSStreamUrl.__init__(self, {}, pageurl, filters)
        self.episodeurl = pageurl
        if hdsurl:
            self.hds_url = hdsurl + '&g=ABCDEFGHIJKL&hdcore=3.3.0&plugin=flowplayer-3.3.0.0'
        else:
            self.hds_url = None
        self.error = None
    
    def is_valid(self):
        return not self.error
    
    def get_error_message(self):
        if self.is_valid():
            return None
        else:
            return self.error or 'Stream not valid'
    
    def to_url(self):
        return self.hds_url

    def to_episode_url(self):
        return self.episodeurl


class Areena2014RTMPStreamUrl(AreenaRTMPStreamUrl):
    def __init__(self, pageurl, streamurl, filters):
        AreenaRTMPStreamUrl.__init__(self, None, pageurl)
        rtmpstream = self.create_rtmpstream(streamurl)
        self.rtmp_params = self.stream_to_rtmp_parameters(rtmpstream, pageurl, False)
        self.rtmp_params['app'] = self.rtmp_params['app'].split('/', 1)[0]

    def create_rtmpstream(self, streamurl):
        (rtmpurl, playpath, ext) = parse_rtmp_single_component_app(streamurl)
        playpath = playpath.split('?', 1)[0]
        return PAPIStream(streamurl, playpath, 0, 0, False)


class InvalidStreamUrl:
    def __init__(self, error_message):
        self.error = error_message

    def is_valid(self):
        return False

    def get_error_message(self):
        return self.error


class PAPIStream:
    def __init__(self, connect, stream, videoBitrate, audioBitrate, hardSubtitles):
        self.connect = connect
        self.stream = stream
        self.videoBitrate = int_or_else(videoBitrate, 0)
        self.audioBitrate = int_or_else(audioBitrate, 0)
        self.hardSubtitles = hardSubtitles

    def __str__(self):
        return json.dumps({
            'connect': self.connect,
            'stream': self.stream,
            'videoBitrate': self.videoBitrate,
            'audioBitrate': self.audioBitrate,
            'hardSubtitles': self.hardSubtitles})

    def bitrate(self):
        return self.videoBitrate + self.audioBitrate


### Areena (the new version with beta introduced in 2014) ###

class Areena2014Downloader(AreenaUtils):
    # Extracted from
    # http://player.yle.fi/assets/flowplayer-1.4.0.3/flowplayer/flowplayer.commercial-3.2.16-encrypted.swf
    AES_KEY = 'yjuap4n5ok9wzg43'

    @staticmethod
    def supported_protocols():
        return ['hds']

    def __init__(self, streaming_protocols):
        pass
    
    def download_episodes(self, url, filters, extra_argv, destdir):
        def download_clip(clip):
            downloader = clip.streamurl.create_downloader(clip.title, destdir,
                                                          extra_argv)
            if not downloader:
                log(u'Downloading the stream at %s is not yet supported.' % url)
                log(u'Try --showurl')
                return RD_FAILED

            outputfile = downloader.output_filename()
            self.download_subtitles(clip.subtitles, filters, outputfile)
            return downloader.save_stream()

        return self.process_single_episode(download_clip, url, filters)

    def print_urls(self, url, print_episode_url, filters):
        def print_clip_url(clip):
            enc = sys.getfilesystemencoding()
            if print_episode_url:
                print_url = clip.streamurl.to_episode_url()
            else:
                print_url = clip.streamurl.to_url()
            print print_url.encode(enc, 'replace')
            return RD_SUCCESS
        
        return self.process_single_episode(print_clip_url, url, filters)

    def pipe(self, url, filters):
        def pipe_clip(clip):
            return clip.streamurl.create_pipe(filters.maxbitrate)

        return self.process_single_episode(pipe_clip, url, filters)

    def print_titles(self, url, filters):
        def print_clip_title(clip):
            enc = sys.getfilesystemencoding()
            print clip.title.encode(enc, 'replace')
            return RD_SUCCESS
        
        return self.process_single_episode(print_clip_title, url, filters)

    def process_single_episode(self, clipfunc, url, filters):
        clip = self.clip_for_url(url, filters)
        if clip.streamurl.is_valid():
            return clipfunc(clip)
        else:
            log(u'Unsupported stream at %s: %s' %
                (url, clip.streamurl.get_error_message()))
            return RD_FAILED

    def clip_for_url(self, pageurl, filters):
        pid = self.program_id_from_url(pageurl)
        if not pid:
            return FailedClip(pageurl, 'Failed to parse a program ID')
        
        programs_jsonp_url = 'http://player.yle.fi/api/v1/programs.jsonp?' \
                             'id=%s&callback=yleEmbed.programJsonpCallback' % \
                             (urllib.quote_plus(pid))
        program_info = self.load_jsonp(programs_jsonp_url)
        if not program_info:
            return FailedClip(pageurl, 'Failed to download program data')

        if debug:
            log('program data:')
            log(str(program_info))

        return self.create_clip(program_info, pid, pageurl, filters)

    def create_clip(self, program_info, program_id, pageurl, filters):
        media_id = self.program_media_id(program_info)
        if not media_id:
            return FailedClip(pageurl, 'Failed to parse media ID')

        proto = self.program_protocol(program_info)
        media_jsonp_url = 'http://player.yle.fi/api/v1/media.jsonp?' \
                          'id=%s&callback=yleEmbed.startPlayerCallback&' \
                          'mediaId=%s&protocol=%s&client=areena-flash-player' % \
            (urllib.quote_plus(media_id), urllib.quote_plus(program_id), \
             urllib.quote_plus(proto))
        media = self.load_jsonp(media_jsonp_url)
        if not media:
            return FailedClip(pageurl, 'Failed to parse media object')

        if debug:
            log('media:')
            log(str(media))

        return Clip(pageurl,
                    self.program_title(program_info),
                    self.media_streamurl(media, pageurl, filters),
                    self.media_subtitles(media))

    def program_id_from_url(self, url):
        parsed = urlparse.urlparse(url)
        return parsed.path.strip('/')

    def program_media_id(self, program_info):
        event = self.publish_event(program_info)
        return event.get('media', {}).get('id')

    def program_title(self, program_info):
        program = program_info.get('data', {}).get('program', {})
        title = self.localized_text(program.get('title')) or \
                self.localized_text(program.get('itemTitle')) or \
                'areena'

        promotionTitle = self.localized_text(program.get('promotionTitle'))
        if promotionTitle and not promotionTitle.startswith(title):
            title += ": " + promotionTitle

        date = self.publish_date(program_info)
        if date:
            title += '-' + date.replace('/', '-').replace(' ', '-')

        return title

    def program_protocol(self, program_info):
        event = self.publish_event(program_info)
        if event.get('media', {}).get('type') == 'AudioObject':
            return 'RTMPE'
        else:
            return 'HDS'

    def publish_date(self, program_info):
        event = self.publish_event(program_info)
        return event.get('startTime')

    def publish_event(self, program_info):
        events = program_info.get('data', {}) \
                             .get('program', {}) \
                             .get('publicationEvent', [])
        with_media = [e for e in events if e.get('media')]
        if with_media:
            return with_media[0]
        else:
            return {}

    def localized_text(self, alternatives, language='fi'):
        if alternatives:
            return alternatives.get(language) or alternatives.get('fi')
        else:
            return None

    def media_streamurl(self, media, pageurl, filters):
        protocol = media.get('meta', {}).get('protocol') or 'HDS'
        mediaobj = media.get('data', {}).get('media', {}).get(protocol, [])
        if mediaobj:
            url = mediaobj[0].get('url')
        else:
            url = None
        if not url:
            return InvalidStreamUrl('No media URL')
        
        decodedurl = self.areena_decrypt(url, self.AES_KEY)
        if not decodedurl:
            return InvalidStreamUrl('Decrypting media URL failed')

        if protocol == 'RTMPE':
            return Areena2014RTMPStreamUrl(pageurl, decodedurl, filters)
        else:
            return Areena2014HDSStreamUrl(pageurl, decodedurl, filters)

    def media_subtitles(self, media):
        hds = media.get('data', {}).get('media', {}).get('HDS', [])
        if hds:
            subs_json = hds[0].get('subtitles', [])
        else:
            subs_json = []
        subtitles = (Subtitle(s.get('uri'), self.three_letter_language_code(s.get('lang'))) for s in subs_json)
        return [s for s in subtitles if s.url]

    def three_letter_language_code(self, lang):
        language_map = {'fi': 'fin', 'sv': 'swe'}
        return language_map.get(lang, lang)

    def load_jsonp(self, url):
        json_string = self.remove_jsonp_padding(download_page(url))
        if not json_string:
            return None

        try:
            json_parsed = json.loads(json_string)
        except ValueError:
            return None

        return json_parsed

    def remove_jsonp_padding(self, jsonp):
        if not jsonp:
            return None
        
        without_padding = re.sub(r'^[\w.]+\(|\);$','', jsonp)
        if without_padding[:1] != '{' or without_padding[-1:] != '}':
            return None

        return without_padding


class Clip:
    def __init__(self, pageurl, title, streamurl, subtitles):
        self.pageurl = pageurl
        self.title = title
        self.streamurl = streamurl
        self.subtitles = subtitles


class FailedClip(Clip):
    def __init__(self, pageurl, errormessage):
        Clip.__init__(self, pageurl, None, InvalidStreamUrl(errormessage), None)


class Subtitle:
    def __init__(self, url, language):
        self.url = url
        self.language = language


### Areena live TV ###
#
# This is for the real live streams
# (http://areena.yle.fi/tv/suora/...). The old-style discrete live
# broadcasts (http://areena.yle.fi/tv/...) are still handled by
# AreenaNGDownloader.


class AreenaLiveDownloader:
    @staticmethod
    def supported_protocols():
        return ['rtmp']

    def __init__(self, streaming_protocols):
        pass

    def download_episodes(self, url, filters, rtmpdumpargs, destdir):
        streamurl = AreenaLiveStreamUrl(url, filters)
        if not streamurl.is_valid():
            return RD_FAILED

        clip_title = self.get_live_stream_title(url)
        downloader = streamurl.create_downloader(clip_title, destdir, rtmpdumpargs)
        return downloader.save_stream()

    def print_urls(self, url, print_episode_url, filters):
        """Extract episodes from url and print their
        librtmp-compatible URLs on stdout."""
        printableurl = (url if print_episode_url
                        else AreenaLiveStreamUrl(url, filters).to_url())
        enc = sys.getfilesystemencoding()
        print printableurl.encode(enc, 'replace')
        return RD_SUCCESS

    def pipe(self, url, filters):
        streamurl = AreenaLiveStreamUrl(url, filters)
        return streamurl.create_pipe(filters.maxbitrate)

    def print_titles(self, url, filters):
        enc = sys.getfilesystemencoding()
        print self.get_live_stream_title(url).encode(enc, 'replace')
        return RD_SUCCESS

    def get_live_stream_title(self, url):
        title = AreenaLiveStreamUrl.extract_live_channel_from_url(url) or 'yleTV'
        title += time.strftime('-%Y-%m-%d-%H:%M:%S')
        return title


### Areena live stream URL ###


class AreenaLiveStreamUrl(AreenaRTMPStreamUrl):
    def __init__(self, pageurl, filters):
        AreenaRTMPStreamUrl.__init__(self, None, pageurl)
        self.rtmp_params = self._get_live_rtmp_parameters(pageurl, filters)

    @staticmethod
    def extract_live_channel_from_url(url):
        m = re.search(r'http://(?:areena.yle.fi/tv/suora|arenan.yle.fi/tv/direkt)/(.+)', url)
        return m and m.group(1)

    def _get_live_rtmp_parameters(self, url, filters):
        channel = AreenaLiveStreamUrl.extract_live_channel_from_url(url)
        if channel is None:
            return None

        default_media_id = 'yle-' + channel
        fem_mapping = {'fem': 'yle-fem-fi',
                       'fem?kieli=sv': 'yle-fem-sv'}
        media_id = fem_mapping.get(channel, default_media_id)
        papiurl = 'http://papi.yle.fi/ng/live/rtmp/' + media_id + '/fin'
        return self.rtmp_parameters_from_papi(papiurl, url, True, filters)


### Areena live radio ###


class AreenaLiveRadioDownloader:
    @staticmethod
    def supported_protocols():
        return ['rtmp']

    def __init__(self, streaming_protocols):
        pass

    def download_episodes(self, url, filters, rtmpdumpargs, destdir):
        streamurl = AreenaLiveRadioStreamUrl(url, filters)
        if not streamurl.is_valid():
            return RD_FAILED
        
        clip_title = self.get_live_stream_title(url)
        downloader = streamurl.create_downloader(clip_title, destdir, rtmpdumpargs)
        return downloader.save_stream()

    def print_urls(self, url, print_episode_url, filters):
        printableurl = (url if print_episode_url
                        else AreenaLiveRadioStreamUrl(url, filters).to_url())
        enc = sys.getfilesystemencoding()
        print printableurl.encode(enc, 'replace')
        return RD_SUCCESS

    def pipe(self, url, filters):
        streamurl = AreenaLiveRadioStreamUrl(url, filters)
        return streamurl.create_pipe(filters.maxbitrate)

    def print_titles(self, url, filters):
        enc = sys.getfilesystemencoding()
        print self.get_live_stream_title(url).encode(enc, 'replace')
        return RD_SUCCESS

    def get_live_stream_title(self, pageurl):
        m = re.match(r'http://(?:www\.)?yle\.fi/radio/([a-zA-Z0-9]+)/suora/?', pageurl)
        title = m.group(1) if m else 'yleradio'
        title += time.strftime('-%Y-%m-%d-%H:%M:%S')
        return title


class AreenaLiveRadioStreamUrl(AreenaRTMPStreamUrl):
    def __init__(self, pageurl, filters):
        AreenaRTMPStreamUrl.__init__(self, None, pageurl)
        self.rtmp_params = self._get_radio_rtmpurl(pageurl, filters)

    def _get_radio_rtmpurl(self, pageurl, filters):
        html = download_page(pageurl)
        if not html:
            return None

        radioid1 = re.search(r'"id": "/([0-9]+)"', html)
        radioid2 = re.search(r'id="live-channel".+data-id="([0-9]+)"', html)
        radioid = radioid1 or radioid2
        if not radioid:
            return None

        streamid = radioid.group(1)
        papiurl = 'http://papi.yle.fi/ng/radio/rtmp/%s/fi' % streamid
        return self.rtmp_parameters_from_papi(papiurl, pageurl, True, filters)


### Elava Arkisto ###


class ElavaArkistoDownloader:
    @staticmethod
    def supported_protocols():
        return ['rtmp']

    def __init__(self, streaming_protocols):
        pass

    def extract_playlist(self, mediajson, pageurl, filters):
        pagedata = json.loads(mediajson)
        if not pagedata.has_key('media'):
            return []

        if debug:
            log('media in pagedata:')
            log(str(pagedata['media']))

        clips = []
        for mediaitem in pagedata['media']:
            stream = ElavaArkistoStreamUrl(mediaitem, pageurl, filters)
            if not stream.is_valid():
                continue
            clips.append(stream)

        return clips

    def print_librtmp_url(self, rtmpurl, playpath, pageurl, downloadURL):
        """Print a librtmp-compatible Elava Arkisto URL to stdout."""
        if downloadURL:
            print downloadURL
        else:
            print '%s playpath=%s swfUrl=%s pageUrl=%s' % \
                (rtmpurl, playpath, ARKISTO_SWF, pageurl)
        return RD_SUCCESS

    def get_playlist(self, url, filters):
        (scheme, netloc, path, params, query, fragment) = urlparse.urlparse(url)

        if '.' in path:
            path = path.rsplit('.', 1)[0]
        path = path + '.json'
        jsonurl = urlparse.urlunparse((scheme, netloc, path, '', '', ''))

        mediajson = download_page(jsonurl)
        if mediajson is None:
            return None

        # Yle server sends UTF-8 but doesn't set charset in
        # Content-type header. This will workaround the problem.
        mediajson = mediajson.encode('iso-8859-1').decode('utf-8')

        playlist = self.extract_playlist(mediajson, url, filters)
        if len(playlist) == 0:
            log(u"Can't find streams at %s." % url)
            return None

        if filters.latest_only:
            playlist = playlist[:1]

        return playlist

    def download_episodes(self, url, filters, rtmpdumpargs, destdir):
        """Download playlist from Elava Arkisto page at url and
        download all clips using rtmpdump."""
        playlist = self.get_playlist(url, filters)
        if playlist is None:
            return RD_FAILED

        overall_status = RD_SUCCESS
        for stream in playlist:
            downloader = stream.create_downloader('', destdir, rtmpdumpargs)
            if not downloader:
                log(u'Downloading the stream at %s is not yet supported.' % url)
                log(u'Try --showurl')
                continue

            status = downloader.save_stream()
            if status != RD_SUCCESS:
                overall_status = status

        return overall_status

    def print_urls(self, url, print_episode_url, filters):
        """Download playlist from Elava Arkisto page at url and print
        a librtmp-compatible URL for each clip."""
        playlist = self.get_playlist(url, filters)
        if playlist is None:
            return RD_FAILED

        if print_episode_url:
            print url
        else:
            enc = sys.getfilesystemencoding()
            for stream in playlist:
                print stream.to_url().encode(enc, 'replace')

        return RD_SUCCESS

    def pipe(self, url, filters):
        log('Elava Arkisto not supported by --pipe.')
        return RD_FAILED

    def print_titles(self, url, filters):
        playlist = self.get_playlist(url, filters)
        if playlist is None:
            return RD_FAILED

        enc = sys.getfilesystemencoding()
        for stream in playlist:
            print stream.clip_title.encode(enc, 'replace')

        return RD_SUCCESS


class ElavaArkistoStreamUrl(AreenaRTMPStreamUrl):
    def __init__(self, mediaitem, pageurl, filters):
        AreenaRTMPStreamUrl.__init__(self, mediaitem, pageurl)
        self._initialize(mediaitem, pageurl, filters)

    def is_valid(self):
        return bool(self.rtmp_params) or bool(self.direct_url)
    
    def to_url(self):
        if self.direct_url:
            return self.direct_url
        else:
            return AreenaRTMPStreamUrl.to_url(self)

    def create_downloader(self, clip_title_ignored, destdir, extra_argv):
        if self.direct_url:
            return HTTPDump(self, self.clip_title, destdir)
        else:
            return RTMPDump(self, self.clip_title, destdir, extra_argv)

    def _initialize(self, mediaitem, pageurl, filters):
        self.clip_title = mediaitem.get('title', 'elavaarkisto')
        self.direct_url = mediaitem.get('downloadURL', None)
        rtmpurl, playpath, self.ext = self._arkisto_rtmp(mediaitem, filters)
        if not rtmpurl:
            rtmpurl, playpath, self.ext = \
                self._mediakanta_rtmp(mediaitem, pageurl, filters)
        self.rtmp_params = {'rtmp': rtmpurl,
                            'playpath': playpath,
                            'pageUrl': pageurl}

    def _arkisto_rtmp(self, mediaitem, filters):
        streams = self._extract_streams_and_bitrates(mediaitem)
        if not streams:
            return (None, None, None)

        if filters.keep_lowest_bitrate():
            selected = sorted(streams, key=itemgetter(0))[0]
        else:
            filtered = [s for s in streams if s[0] <= filters.maxbitrate]
            if not filtered:
                log('No streams matching the bitrate limit')
                return (None, None, None)
            selected = sorted(streams, key=itemgetter(0))[-1]

        if debug:
            log('Selected by bitrate filter: ' + str(selected))
            
        return parse_rtmp_single_component_app(selected[1])

    def _extract_streams_and_bitrates(self, mediaitem):
        streams = []
        for clip in mediaitem.get('urls', {}).get('domestic', []):
            rate = float(clip.get('bitrate', 0))
            url = clip.get('url', '')
            streams.append((rate, url))
        return streams

    def _mediakanta_rtmp(self, mediaitem, pageurl, filters):
        if mediaitem.get('mediakantaId', '') != '':
            papiurl = 'http://papi.yle.fi/ea/mod/rtmp/' + mediaitem['mediakantaId']
            rtmp_params = self.rtmp_parameters_from_papi(papiurl, pageurl, False, filters)
            playpath = rtmp_params['playpath']
            ext = os.path.splitext(playpath)[1] or '.mp3'
            return (rtmp_params['rtmp'], playpath, ext)
        else:
            return (None, None, None)


### YleX Areena ###


class YleXDownloader(AreenaNGDownloader):
    @staticmethod
    def supported_protocols():
        return ['rtmp']

    def __init__(self, streaming_protocols):
        pass

    def download_episodes(self, url, filters, argv, destdir):
        """Download a stream from the given YleX Areena url using
        rtmpdump."""
        html = download_page(url)
        if not html:
            return RD_FAILED

        streamurl = YleXStreamUrl(html, url, filters)
        if not streamurl.is_valid():
            return RD_FAILED

        stream_title = self.stream_title(html)
        extra_args = RTMPDUMP_OPTIONS_YLEX + argv
        downloader = streamurl.create_downloader(stream_title, destdir, extra_args)
        return downloader.save_stream()

    def print_urls(self, url, print_episode_url, filters):
        """Print a librtmp-compatible YleX Areena URL to stdout."""
        html = download_page(url)
        if not html:
            return RD_FAILED

        streamurl = YleXStreamUrl(html, url, filters)
        if not streamurl.is_valid():
            return RD_FAILED

        enc = sys.getfilesystemencoding()
        printableurl = None
        if print_episode_url:
            printableurl = streamurl.to_episode_url()
        else:
            printableurl = streamurl.to_url()
        print printableurl.encode(enc, 'replace')
        return RD_SUCCESS

    def pipe(self, url, filters):
        html = download_page(url)
        streamurl = YleXStreamUrl(html, url, filters)
        return streamurl.create_pipe(filters.maxbitrate)

    def print_titles(self, url, filters):
        enc = sys.getfilesystemencoding()
        print self.stream_title(download_page(url)).encode(enc, 'replace')
        return RD_SUCCESS

    def stream_title(self, html):
        if html:
            match = re.search(r'<meta +?property="og:title" +?content="(.+?)" *?/>', html)
            if match:
                return replace_entitydefs(match.group(1))

        return time.strftime('YleX-%Y-%m-%d-%H:%M:%S')


### YleX Areena stream URL ###


class YleXStreamUrl(AreenaRTMPStreamUrl):
    def __init__(self, html, url, filters):
        AreenaRTMPStreamUrl.__init__(self, None, url)
        self.rtmp_params = self._parse_rtmp_params(html, url, filters)

    def _parse_rtmp_params(self, html, pageurl, filters):
        match = re.search(r'<meta +?property="og:image" +?content="(.+?)" *?/>', html)
        if not match:
            return None

        match = re.search(r'/([a-fA-F0-9]+)_', match.group(1))
        if not match:
            return None

        papiurl = 'http://papi.yle.fi/ng/mod/rtmp/%s' % match.group(1)
        return self.rtmp_parameters_from_papi(papiurl, pageurl, False, filters)


### Downloader wrapper class that retries different protocols ###


class RetryingDownloader:
    def __init__(self, wrapped_class, protocols):
        self.wrapped_class = wrapped_class
        supported_protocols = wrapped_class.supported_protocols()
        required_or_default_protocols = protocols or supported_protocols
        self.protocols = \
          [x for x in required_or_default_protocols if x in supported_protocols]

        unsupported = frozenset(protocols or []) - frozenset(self.protocols)
        if unsupported:
            log(u'The following protocols are not supported on this source: ' +
                u', '.join(unsupported))

    def _create_next_downloader(self):
        if self.protocols:
            proto = self.protocols.pop(0)
            if debug:
                log('Streaming protocol %s' % proto)
            return self.wrapped_class(proto)
        else:
            return None

    def _retry_call(self, method_name, *args, **kwargs):
        downloader = self._create_next_downloader()
        if not downloader:
            return RD_FAILED

        method = getattr(downloader, method_name)
        res = method(*args, **kwargs)
        if res == RD_FAILED:
            return self._retry_call(method_name, *args, **kwargs)
        else:
            return res

    def print_urls(self, *args, **kwargs):
        return self._retry_call('print_urls', *args, **kwargs)

    def print_titles(self, *args, **kwargs):
        return self._retry_call('print_titles', *args, **kwargs)

    def download_episodes(self, *args, **kwargs):
        return self._retry_call('download_episodes', *args, **kwargs)

    def pipe(self, *args, **kwargs):
        return self._retry_call('pipe', *args, **kwargs)


### Dumping a stream to a file using external programs ###


class ExternalDownloader:
    def __init__(self, stream, clip_title, destdir, extra_argv):
        self.stream = stream
        self.clip_title = clip_title or 'ylestream'
        self.extra_argv = extra_argv
        self.destdir = destdir or ''
        self._cached_output_file = None

    def save_stream(self):
        args = self.build_args()
        outputfile = self.outputfile_from_args(args)
        self.log_output_file(outputfile)
        retcode = self.external_downloader(args)
        if retcode == RD_SUCCESS:
            self.log_output_file(outputfile, True)
        return retcode

    def outputfile_from_clip_title(self, ext='.flv', resume=False):
        if self._cached_output_file:
            return self._cached_output_file
        
        filename = self.sane_filename(self.clip_title) + ext
        if self.destdir:
            filename = os.path.join(self.destdir, filename)
        if not resume:
            filename = self.next_available_filename(filename)
        self._cached_output_file = filename
        return filename
        
    def next_available_filename(self, proposed):
        i = 1
        enc = sys.getfilesystemencoding()
        filename = proposed
        basename, ext = os.path.splitext(filename)
        while os.path.exists(filename.encode(enc, 'replace')):
            log(u'%s exists, trying an alternative name' % filename)
            filename = basename + '-' + str(i) + ext
            i += 1

        return filename

    def build_args(self):
        return []

    def external_downloader(self, args):
        """Start an external process such as rtmpdump with argument list args and
        wait until completion.
        """
        if debug:
            log('Executing:')
            log(' '.join(args))

        enc = sys.getfilesystemencoding()
        encoded_args = [x.encode(enc, 'replace') for x in args]

        try:
            if platform.system() == 'Windows':
                process = subprocess.Popen(encoded_args)
            else:
                process = subprocess.Popen(encoded_args,
                    preexec_fn=self._sigterm_when_parent_dies)
            return process.wait()
        except KeyboardInterrupt:
            try:
                os.kill(process.pid, signal.SIGINT)
                process.wait()
            except OSError:
                # The process died before we killed it.
                pass
            return RD_INCOMPLETE
        except OSError, exc:
            log(u'Failed to execute ' + ' '.join(args))
            log(unicode(exc.strerror, 'UTF-8', 'replace'))
            return RD_FAILED

    def _sigterm_when_parent_dies(self):
       PR_SET_PDEATHSIG = 1

       try:
           libc.prctl(PR_SET_PDEATHSIG, signal.SIGTERM)
       except AttributeError:
           # libc is None or libc does not contain prctl
           pass

    def outputfile_from_args(self, args_in):
        prev = None
        args = list(args_in) # copy
        while args:
            opt = args.pop()
            if opt in ('-o', '--flv'):
                if prev:
                    return prev
                else:
                    return None
            prev = opt
        return None

    def log_output_file(self, outputfile, done=False):
        if outputfile and outputfile != '-':
            if done:
                log(u'Stream saved to ' + outputfile)
            else:
                log(u'Output file: ' + outputfile)

    def sane_filename(self, name):
        if isinstance(name, unicode):
            tr = dict((ord(c), ord(u'_')) for c in excludechars)
        else:
            tr = string.maketrans(excludechars, '_'*len(excludechars))
        x = name.strip(' .').translate(tr)
        if x:
            return x
        else:
            return 'ylevideo'

    def output_filename(self):
        return (self.outputfile_from_args(self.extra_argv) or
                self.outputfile_from_clip_title())


class RTMPDump(ExternalDownloader):
    def build_args(self):
        args = [rtmpdump_binary]
        args += self.stream.to_rtmpdump_args()
        args += self._outputparams_unless_defined_in_extra_argv()
        args += self.extra_argv
        return args

    def output_filename(self):
        resume_job = self.is_resume_job(self.extra_argv)
        return (self.outputfile_from_args(self.extra_argv) or
                self.outputfile_from_clip_title(resume=resume_job))

    def _outputparams_unless_defined_in_extra_argv(self):
        if self.outputfile_from_args(self.extra_argv):
            return []
        else:
            return ['-o', self.output_filename()]

    def is_resume_job(self, args):
        return '--resume' in args or '-e' in args


class HDSDump(ExternalDownloader):
    def __init__(self, stream, clip_title, destdir, extra_argv, maxbitrate):
        ExternalDownloader.__init__(self, stream, clip_title, destdir, extra_argv)
        self.quality_options = self._bitrate_to_quality(maxbitrate)

    def _bitrate_to_quality(self, maxbitrate):
        # Approximate because there is no easy way to find out the
        # available bitrates in the HDS stream
        if maxbitrate < 1000:
            return ['--quality', 'low']
        elif maxbitrate < 2000:
            return ['--quality', 'medium']
        else:
            return []

    def build_args(self):
        args = list(hds_binary)
        args.append('--manifest')
        args.append(self.stream.to_url())
        args.append('--delete')
        args.append('--outfile')
        args.append(self.output_filename())
        args.extend(self.quality_options)
        return args


class HTTPDump(ExternalDownloader):
    def __init__(self, stream, clip_title, destdir):
        ExternalDownloader.__init__(self, stream, clip_title, destdir, None)

    def save_stream(self):
        log('Downloading from HTTP server...')
        if debug:
            log('URL: %s' % self.stream.to_url())
        filename = self.output_filename()
        self.log_output_file(filename)

        enc = sys.getfilesystemencoding()
        try:
            urllib.urlretrieve(self.stream.to_url(), filename.encode(enc))
        except IOError, exc:
            log(u'Download failed: ' + unicode(exc.message, 'UTF-8', 'replace'))
            return RD_FAILED

        self.log_output_file(filename, True)
        return RD_SUCCESS

    def output_filename(self):
        ext = self.stream.ext or '.flv'
        return (self.outputfile_from_args(self.extra_argv) or
                self.outputfile_from_clip_title(ext=ext))


### main program ###


def main():
    global debug
    global rtmpdump_binary
    global hds_binary
    latest_episode = False
    url_only = False
    title_only = False
    print_episode_url = False
    sublang = 'all'
    hardsubs = False
    bitratearg = sys.maxint
    show_usage = False
    url = None
    destdir = None
    streaming_protocols = None
    pipe = False

    # Is sys.getfilesystemencoding() the correct encoding for
    # sys.argv?
    encoding = sys.getfilesystemencoding()
    argv = [unicode(x, encoding, 'ignore') for x in sys.argv[1:]]
    rtmpdumpargs = []
    while argv:
        arg = argv.pop(0)
        if not arg.startswith('-'):
            url = arg
        elif arg in ['--verbose', '-V', '--debug', '-z']:
            debug = True
            rtmpdumpargs.append(arg)
        elif arg in ['--help', '-h']:
            show_usage = True
        elif arg in ['--latestepisode']:
            latest_episode = True
        elif arg == '--showurl':
            url_only = True
        elif arg == '--showtitle':
            title_only = True
        elif arg == '--showepisodepage':
            url_only = True
            print_episode_url = True
        elif arg == '--vfat':
            global excludechars
            global excludechars_windows
            excludechars = excludechars_windows
        elif arg == '--sublang':
            if argv:
                sublang = argv.pop(0)
        elif arg == '--hardsubs':
            hardsubs = True
        elif arg == '--maxbitrate':
            if argv:
                bitratearg = argv.pop(0)
        elif arg == '--rtmpdump':
            if argv:
                rtmpdump_binary = argv.pop(0)
        elif arg == '--adobehds':
            if argv:
                hds_binary = argv.pop(0).split(' ')
        elif arg == '--destdir':
            if argv:
                destdir = argv.pop(0)
        elif arg == '--protocol':
            if argv:
                streaming_protocols = argv.pop(0).split(',')
        elif arg == '--pipe':
            pipe = True
        else:
            rtmpdumpargs.append(arg)
            if arg in ARGOPTS and argv:
                rtmpdumpargs.append(argv.pop(0))

    if not rtmpdump_binary:
        if sys.platform == 'win32':
            rtmpdump_binary = which('rtmpdump.exe')
        else:
            rtmpdump_binary = which('rtmpdump')

    if show_usage or url is None:
        usage()
        sys.exit(RD_FAILED)

    if debug or not (url_only or title_only):
        splashscreen()

    if not rtmpdump_binary:
        log(u'Error: rtmpdump not found in path, use --rtmpdump for setting the location')
        sys.exit(RD_FAILED)

    url = encode_url_utf8(url)
    dl = downloader_factory(url, streaming_protocols)
    if not dl:
        log(u'Unsupported URL %s.' % url)
        log(u'Is this really a Yle video page?')
        sys.exit(RD_FAILED)

    maxbitrate = bitrate_from_arg(bitratearg)
    sfilt = StreamFilters(latest_episode, sublang, hardsubs, maxbitrate)
    if url_only:
        sys.exit(dl.print_urls(url, print_episode_url, sfilt))
    elif title_only:
        sys.exit(dl.print_titles(url, sfilt))
    elif pipe:
        sys.exit(dl.pipe(url, sfilt))
    else:
        sys.exit(dl.download_episodes(url, sfilt, rtmpdumpargs, destdir))


if __name__ == '__main__':
    main()
